# Project Learnings

### 2026-02-15
- [closeness centrality]: igraph::closeness() defaults to normalized=FALSE (returns 1/sum(distances)), not normalized=TRUE ((n-1)/sum(distances)). Python implementation was using n_reachable/total_dist which equals (n-1)/total_dist for fully connected graphs — 8x off for the 9-state group_regulation dataset.
- [closeness mode=all]: igraph mode="all" treats directed edges as bidirectional. For each edge pair (u,v), the effective undirected weight is max(w(u,v), w(v,u)). NetworkX's DiGraph.to_undirected() does NOT properly combine bidirectional edge weights — must manually build undirected graph with max weight per edge pair.
- [ctna implementation]: Python ctna counts only adjacent bidirectional co-occurrences (each adjacent pair counted in both directions). R ctna uses window-based co-occurrence counting, producing much larger counts. Raw co-occurrence matrices are intentionally different between R and Python.
- [R TNA centralities]: R TNA 1.2.0 calls igraph functions with weights=1/edge_weight (invert=TRUE default). The centrality_funs dispatch closeness with mode="in"/"out"/"all" and betweenness without normalized parameter.
- [test validation]: Original test_r_equivalence.py only checked structural properties (shapes, ranges, non-negative, finite). Never compared against actual R output values. Tests can pass while being numerically wrong.
- [R ground truth]: Full precision R values obtained from R TNA 1.2.0 / igraph 2.2.1. Weight matrix and centralities match Python within ~1e-15 (machine epsilon) after fixes.
- [R bootstrap algorithm]: R TNA bootstrap resamples **per-sequence 3D transition arrays** (not raw sequences). Core unit: `trans[n_sequences, n_states, n_states]` built via `compute_transitions()`, then `trans[sample(idx, n, replace=TRUE), , ]`. Original Python resampled raw rows — fundamentally different algorithm.
- [R bootstrap stability]: R stability method counts exceedances `(wb <= w*0.75) + (wb >= w*1.25)` per iteration. P-values = `(count+1)/(iter+1)` — can exceed 1.0 for zero-weight edges (both conditions fire). This is intentional R behavior.
- [R permutation test]: R permutation combines 3D transitions from both groups, shuffles sequence indices, splits into two groups, computes weight difference per edge. Effect size = `diff_true / sd(perm_diffs)` with `ddof=1`.
- [R as.vector column-major]: R's `as.vector()` outputs matrices in column-major order (column 1 first, then column 2...). When comparing 81-element vectors from R 9x9 matrices, must use `order='F'` (Fortran/column-major) when reshaping in Python.
- [R p.adjust]: R's `p.adjust()` Holm method sorts ascending, applies `max(1, n-i+1) * p[i]`, enforces monotonicity with cumulative max, then restores original order. BH/FDR sorts ascending, applies `n/rank * p`, enforces monotonicity with cumulative min from the right.

### 2026-02-16
- [matplotlib arrows]: FancyArrowPatch arrowstyle `->,head_length=X,head_width=Y` combined with `mutation_scale` controls arrowhead size. Original `/15` and `/25` ratios with `mutation_scale=15` produce small arrows. Ratios of `/10` and `/15` with `mutation_scale=20` were too large. Final sweet spot: `/15` and `/22` with `mutation_scale=15`.
- [edge label placement]: Positioning edge labels at 65% along the edge towards the destination (`x1 + 0.65 * (x2 - x1)`) makes labels visually associate with their target node, much clearer than the default midpoint (50%).
- [notebook DPI]: Default `figure.dpi = 100` produces low-resolution plots in HTML exports. `150` is a good balance for quality vs file size.
- [jupyter kernel]: The project has a dedicated `tnapy` kernel (at `~/Library/Jupyter/kernels/tnapy/`) using the `.venv` virtualenv. The system Python (`/opt/homebrew/bin/python3`) lacks numpy/pandas. Always use `--ExecutePreprocessor.kernel_name=tnapy` when running `nbconvert --execute`.
- [GroupTNA duck typing]: Used `_is_group_tna(x)` with `hasattr(x, 'models')` to avoid circular imports between `group.py` and other modules (`centralities.py`, `prune.py`, `communities.py`, `cliques.py`, `bootstrap.py`, `plot.py`).
- [GroupTNA dispatch pattern]: Each analysis function checks `_is_group_tna(model)` at the top and dispatches per-group, returning combined results (DataFrame with 'group' column for centralities, GroupTNA for prune, dict for communities/cliques/bootstrap).
- [plot GroupTNA]: Multi-panel plots use `fig_w = figsize[0] * n_groups` to scale figure width by group count, with `plt.subplots(1, n_groups)`. Must handle `n_groups == 1` case where `axes` is not a list.
- [estimate_cs algorithm]: Case-dropping bootstrap uses `rng.choice(n, size=n_keep, replace=False)` — WITHOUT replacement, key difference from regular bootstrap. CS coefficient = max drop_prop where >=95% of correlations stay above 0.7. Zero-SD measures (constant across states) get CS=0.
- [installed vs local package]: When running scripts from `tmp/`, Python may pick up a stale *installed* copy from `.venv/lib/.../site-packages/tna/` instead of the local `tna/` source. Running `pip install -e .` ensures editable mode resolves this.
- [chi2_contingency]: `scipy.stats.chi2_contingency` requires at least 2 non-zero rows and 2 non-zero columns. Must filter out zero-sum rows/cols before calling. Standardized residuals = `(observed - expected) / sqrt(expected)`.
- [plot_compare]: Difference network colors edges by sign of `x.weights - y.weights` (green=positive, red=negative). Node fill alpha scaled by `|init_diff|`. Must reorder y's weights/inits to match x's label order before computing diff.
- [R calculate_cs]: R uses `max(which(prop_above >= certainty))` — finds ALL valid drop proportions and takes the maximum. NOT sequential break (correlations can dip below threshold then recover). Python `_calculate_cs` must use `np.where()` + `max`, not loop-with-break.
- [R n_drop]: R uses `n_drop <- floor(n * prop)` and `keep <- sample(n_seq, n - n_drop)`. Python must use `int(np.floor(n * dp))` not `int(round(n * (1 - dp)))` — difference of 1 for some n/dp combinations.
- [R plot_mosaic transpose]: R's `plot_mosaic` uses `as.table(t(weights))` — transposed weight matrix. X-axis = "Incoming edges" (to-states), Y-axis = "Outgoing edges" (from-states). Only supported for frequency/co-occurrence types.
- [R chisq.test stdres]: R's `chisq.test()$stdres` are **adjusted** standardized residuals: `(O - E) / sqrt(E * (1 - ri/N) * (1 - cj/N))`, NOT simple Pearson residuals `(O - E) / sqrt(E)`. The denominator accounts for marginal proportions. R uses fixed color limits [-4, 4] for the mosaic colorbar.
- [R TNA LCS formula]: R TNA `lcs_dist` uses `max(m, n) - lcs_length`, NOT the standard `m + n - 2 * lcs_length`. These give different results for unequal-length sequences. Python implementation uses R's formula for compatibility.
- [R TNA lv/osa bug]: R TNA 1.2.0 `levenshtein_dist` and `osa_dist` have inverted cost: `0L + 1L * (x[i] == y[j])` assigns cost=1 for matches and cost=0 for mismatches, producing incorrect distances (most pairs distance 0). Python implementation uses the correct standard algorithm.
- [scipy fcluster ties]: `scipy.cluster.hierarchy.fcluster(Z, t=k, criterion='maxclust')` fails when the last merge heights are tied — may return fewer clusters than requested. Use `cut_tree(Z, n_clusters=k)` instead, which matches R's `cutree()` behavior.
- [R import_onehot format]: R's `import_onehot` produces one row per actor/group with W{w}_T{t} column naming (all windows concatenated). Python version produces one row per window with action_{i} columns. Different output shapes but both compatible with TNA analysis.
- [cluster_sequences R match]: Hamming distances, LCS distances, PAM clustering (assignments, silhouette, sizes), and hierarchical clustering (complete, average) all match R TNA exactly. Minor differences possible in hierarchical methods when merge distances are tied (tie-breaking differs between scipy and R hclust).
- [compare_sequences R match]: Frequencies (918 patterns) and proportions match R exactly to machine epsilon (~1e-16). R computes proportions per subsequence-length group BEFORE min_freq filtering (denominator includes all patterns, not just filtered ones). R runs permutation test on ALL patterns before filtering, so Bonferroni uses full pattern count per length. Output sorted by length then alphabetical (no test) or by p_value (with test).
- [compare_sequences permutation]: Pre-computing (row_index → pattern_indices) mapping speeds permutation loop ~3x: only need to re-accumulate counts by permuted group, not re-extract patterns each iteration.
- [compare_sequences p_adjust grouping]: R adjusts p-values separately per subsequence length group. E.g. 9 unigrams get Bonferroni factor 9, 78 bigrams get factor 78. Each raw p = 1/(iter+1) when all permuted stats < true stat.

### 2026-02-17
- [tnaj computeTransitions3D nCols bug]: `computeTransitions3D` uses `data[0].length` as the number of time steps for ALL sequences. With variable-length sequences (e.g. 2–26 in regulation data), only transitions up to the first sequence's length are counted — longer sequences are silently truncated. Fix: pad all sequences to max length with `null` before calling. The `null` values are caught by `isNA()` internally.
- [permutation test trueDiff mismatch]: Original permutation test computed true differences from `x.weights - y.weights` (original model weights), but permuted differences from `computeWeightsFrom3D(combinedTrans)`. Since each group model uses a different `nCols` (first sequence's length), the true and permuted weights were computed differently, making p-values systematically inflated (~0.9 for all edges). Fix: recompute true weights from the 3D transitions using the same pipeline as permutations.
- [multi-group grid layout]: For displaying all groups simultaneously, use CSS `grid-template-columns: repeat(auto-fit, minmax(500px, 1fr))` for responsive card layout. Scale network heights down in group mode: 450px for 2 groups, 380px for 3+. Use color-coded card headers with `nth-child` dot colors.
- [DOM ID collisions in multi-group]: When rendering the same tab type multiple times (once per group), all `getElementById` calls collide. Solution: add `idSuffix = ''` parameter to tab renderers, append `-g{index}` to every hardcoded ID. External renderers (bootstrap, betweenness, cliques, patterns, indices) get suffix as parameter; inline renderers (network, centralities, frequencies, sequences, communities) are duplicated as `*Multi` variants.
- [per-group caching]: Replace single `cachedModel`/`cachedCent` with `Map<string, TNA>` / `Map<string, CentralityResult>` for instant tab switching across groups. Populate all group caches upfront in `updateAll()`.
- [group-only tabs vs per-group tabs]: Tabs that compare across groups (permutation, compare-sequences, compare-networks) should NOT be multi-grouped — they already handle GroupTNA internally. Only per-group analysis tabs (network, centralities, bootstrap, etc.) get the multi-group grid treatment.

### 2026-02-18
- [R CTNA all-pairs]: R's co-occurrence counts ALL pairs `(i,j)` where `i < j` within each sequence, NOT just adjacent pairs. The 2D `_transitions_cooccurrence` in both Python and JS was wrong (adjacent only). The 3D `compute_transitions_3d`/`computeTransitions3D` was already correct. Fixed both 2D functions to match.
- [CTNA self-loop R behavior]: R's vectorized `trans[new_trans] <- trans[new_trans] + weight` with duplicate indices (self-loops where from==to) only applies the LAST assignment — effectively adding weight once, not twice. JS/Python `+= 1; += 1` accumulates twice. Self-loops are double-counted in JS/Python relative to R.
- [CTNA undirected rendering]: Co-occurrence matrices are symmetric. Network should render ONE undirected edge per pair (no arrowheads, straight lines), not two directed arrows. Self-loops also rendered without arrowheads.
- [rank scaling + symmetric matrix]: Rank scaling on a symmetric co-occurrence matrix produces `.50` values for ALL off-diagonal edges because every value `(i,j)` ties with its mirror `(j,i)`, giving average ranks ending in `.5`. This is expected behavior, not a bug.
- [model type change UX]: When user changes model type (TNA→CTNA etc.), reset scaling to "None" and threshold to 0 for a clean slate. Navigate to Network tab. Fully recalculate all models including group analysis.
- [chi-square mosaic]: State frequency × Cluster mosaic uses Pearson chi-square with adjusted standardized residuals. RdBu discrete color bins at ±2, ±4 thresholds. Dashed borders for negative residuals. P-value from regularized incomplete gamma function (Lanczos lgamma + series/continued-fraction gammaP).
- [difference network]: Compare Networks diff = modelA.weights - modelB.weights. Green (#28a745) for positive, red (#dc3545) for negative. Edge width ∝ |diff|.
- [tna-desktop three-mode nav]: Replaced flat 13-tab bar with two-level navigation: Mode bar (Single Network / Clustering / Group Analysis) + Subtab bar per mode. AppState uses `activeMode` + `activeSubTab` instead of `activeTab`. SETTINGS_VERSION bumped to 10. CSS uses `.mode-bar` (segmented control) + `.subtab-bar` (replaces `.tab-bar`). Group Analysis mode disabled when `!state.groupLabels`. Subtabs disabled until groups activated. clustering.ts exports `renderClusteringSetup`, `renderGroupSetup`, `renderGroupGrid`, `renderCombinedCanvas` for dashboard to compose.
- [bootstrap CI quantiles]: JS used `Math.floor` rank indexing for confidence intervals, which picks the nearest lower element. R's `stats::quantile` type 7 uses linear interpolation between adjacent order statistics: `idx = p * (n-1)`, then `sorted[floor(idx)] * (1-frac) + sorted[ceil(idx)] * frac`. tnaj's `arrayQuantile` already implements type 7 correctly.
- [permutation trueDiff source]: R computes `trueDiff = weights_x - weights_y` directly from model weights. JS was recomputing from padded/combined 3D transitions, which could differ from the original model weights due to the padding pipeline. Fixed to use model weights directly (permuted diffs still use the combined-transitions pipeline, matching R).
- [permutation paired option]: R supports `paired=TRUE` for equal-size groups: instead of full shuffle, randomly swap within each pair `(x_i, y_i)` with probability 0.5. Requires `nX === nY`.
- [stability NaN correlation]: Replacing `NaN` correlations with `0` inflates the proportion-above-threshold count (0 < threshold counts as "not above", but also inflates the denominator). Correct approach: filter NaN values before computing means and CS coefficients, matching R's `na.rm=TRUE` behavior.
- [stability spearman]: R supports `cor.method = "spearman"` for centrality stability. Spearman = Pearson on ranks. For tied values, use average ranks (mean of positions sharing the same value).
- [walktrap vs louvain]: Both tnaj and tna-desktop mapped walktrap to louvain. R's walktrap (Pons & Latapy 2005) is fundamentally different: computes P^t (t-step random walk distributions on the **directed** graph, default t=4), then Ward-style agglomerative clustering minimizing walk-distance, returning the partition at maximum modularity. All other community methods use symmetrized adjacency; walktrap is the only one that uses the directed graph.
- [pattern delimiter]: R TNA uses `->` as the n-gram pattern delimiter. JS was using ` → ` (Unicode arrow with spaces), causing pattern string mismatches when comparing outputs.
