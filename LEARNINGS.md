# Project Learnings

### 2026-02-15
- [closeness centrality]: igraph::closeness() defaults to normalized=FALSE (returns 1/sum(distances)), not normalized=TRUE ((n-1)/sum(distances)). Python implementation was using n_reachable/total_dist which equals (n-1)/total_dist for fully connected graphs — 8x off for the 9-state group_regulation dataset.
- [closeness mode=all]: igraph mode="all" treats directed edges as bidirectional. For each edge pair (u,v), the effective undirected weight is max(w(u,v), w(v,u)). NetworkX's DiGraph.to_undirected() does NOT properly combine bidirectional edge weights — must manually build undirected graph with max weight per edge pair.
- [ctna implementation]: Python ctna counts only adjacent bidirectional co-occurrences (each adjacent pair counted in both directions). R ctna uses window-based co-occurrence counting, producing much larger counts. Raw co-occurrence matrices are intentionally different between R and Python.
- [R TNA centralities]: R TNA 1.2.0 calls igraph functions with weights=1/edge_weight (invert=TRUE default). The centrality_funs dispatch closeness with mode="in"/"out"/"all" and betweenness without normalized parameter.
- [test validation]: Original test_r_equivalence.py only checked structural properties (shapes, ranges, non-negative, finite). Never compared against actual R output values. Tests can pass while being numerically wrong.
- [R ground truth]: Full precision R values obtained from R TNA 1.2.0 / igraph 2.2.1. Weight matrix and centralities match Python within ~1e-15 (machine epsilon) after fixes.
- [R bootstrap algorithm]: R TNA bootstrap resamples **per-sequence 3D transition arrays** (not raw sequences). Core unit: `trans[n_sequences, n_states, n_states]` built via `compute_transitions()`, then `trans[sample(idx, n, replace=TRUE), , ]`. Original Python resampled raw rows — fundamentally different algorithm.
- [R bootstrap stability]: R stability method counts exceedances `(wb <= w*0.75) + (wb >= w*1.25)` per iteration. P-values = `(count+1)/(iter+1)` — can exceed 1.0 for zero-weight edges (both conditions fire). This is intentional R behavior.
- [R permutation test]: R permutation combines 3D transitions from both groups, shuffles sequence indices, splits into two groups, computes weight difference per edge. Effect size = `diff_true / sd(perm_diffs)` with `ddof=1`.
- [R as.vector column-major]: R's `as.vector()` outputs matrices in column-major order (column 1 first, then column 2...). When comparing 81-element vectors from R 9x9 matrices, must use `order='F'` (Fortran/column-major) when reshaping in Python.
- [R p.adjust]: R's `p.adjust()` Holm method sorts ascending, applies `max(1, n-i+1) * p[i]`, enforces monotonicity with cumulative max, then restores original order. BH/FDR sorts ascending, applies `n/rank * p`, enforces monotonicity with cumulative min from the right.

### 2026-02-16
- [matplotlib arrows]: FancyArrowPatch arrowstyle `->,head_length=X,head_width=Y` combined with `mutation_scale` controls arrowhead size. Original `/15` and `/25` ratios with `mutation_scale=15` produce small arrows. Ratios of `/10` and `/15` with `mutation_scale=20` were too large. Final sweet spot: `/15` and `/22` with `mutation_scale=15`.
- [edge label placement]: Positioning edge labels at 65% along the edge towards the destination (`x1 + 0.65 * (x2 - x1)`) makes labels visually associate with their target node, much clearer than the default midpoint (50%).
- [notebook DPI]: Default `figure.dpi = 100` produces low-resolution plots in HTML exports. `150` is a good balance for quality vs file size.
- [jupyter kernel]: The project has a dedicated `tnapy` kernel (at `~/Library/Jupyter/kernels/tnapy/`) using the `.venv` virtualenv. The system Python (`/opt/homebrew/bin/python3`) lacks numpy/pandas. Always use `--ExecutePreprocessor.kernel_name=tnapy` when running `nbconvert --execute`.
- [GroupTNA duck typing]: Used `_is_group_tna(x)` with `hasattr(x, 'models')` to avoid circular imports between `group.py` and other modules (`centralities.py`, `prune.py`, `communities.py`, `cliques.py`, `bootstrap.py`, `plot.py`).
- [GroupTNA dispatch pattern]: Each analysis function checks `_is_group_tna(model)` at the top and dispatches per-group, returning combined results (DataFrame with 'group' column for centralities, GroupTNA for prune, dict for communities/cliques/bootstrap).
- [plot GroupTNA]: Multi-panel plots use `fig_w = figsize[0] * n_groups` to scale figure width by group count, with `plt.subplots(1, n_groups)`. Must handle `n_groups == 1` case where `axes` is not a list.
- [estimate_cs algorithm]: Case-dropping bootstrap uses `rng.choice(n, size=n_keep, replace=False)` — WITHOUT replacement, key difference from regular bootstrap. CS coefficient = max drop_prop where >=95% of correlations stay above 0.7. Zero-SD measures (constant across states) get CS=0.
- [installed vs local package]: When running scripts from `tmp/`, Python may pick up a stale *installed* copy from `.venv/lib/.../site-packages/tna/` instead of the local `tna/` source. Running `pip install -e .` ensures editable mode resolves this.
- [chi2_contingency]: `scipy.stats.chi2_contingency` requires at least 2 non-zero rows and 2 non-zero columns. Must filter out zero-sum rows/cols before calling. Standardized residuals = `(observed - expected) / sqrt(expected)`.
- [plot_compare]: Difference network colors edges by sign of `x.weights - y.weights` (green=positive, red=negative). Node fill alpha scaled by `|init_diff|`. Must reorder y's weights/inits to match x's label order before computing diff.
- [R calculate_cs]: R uses `max(which(prop_above >= certainty))` — finds ALL valid drop proportions and takes the maximum. NOT sequential break (correlations can dip below threshold then recover). Python `_calculate_cs` must use `np.where()` + `max`, not loop-with-break.
- [R n_drop]: R uses `n_drop <- floor(n * prop)` and `keep <- sample(n_seq, n - n_drop)`. Python must use `int(np.floor(n * dp))` not `int(round(n * (1 - dp)))` — difference of 1 for some n/dp combinations.
- [R plot_mosaic transpose]: R's `plot_mosaic` uses `as.table(t(weights))` — transposed weight matrix. X-axis = "Incoming edges" (to-states), Y-axis = "Outgoing edges" (from-states). Only supported for frequency/co-occurrence types.
- [R chisq.test stdres]: R's `chisq.test()$stdres` are **adjusted** standardized residuals: `(O - E) / sqrt(E * (1 - ri/N) * (1 - cj/N))`, NOT simple Pearson residuals `(O - E) / sqrt(E)`. The denominator accounts for marginal proportions. R uses fixed color limits [-4, 4] for the mosaic colorbar.
- [R TNA LCS formula]: R TNA `lcs_dist` uses `max(m, n) - lcs_length`, NOT the standard `m + n - 2 * lcs_length`. These give different results for unequal-length sequences. Python implementation uses R's formula for compatibility.
- [R TNA lv/osa bug]: R TNA 1.2.0 `levenshtein_dist` and `osa_dist` have inverted cost: `0L + 1L * (x[i] == y[j])` assigns cost=1 for matches and cost=0 for mismatches, producing incorrect distances (most pairs distance 0). Python implementation uses the correct standard algorithm.
- [scipy fcluster ties]: `scipy.cluster.hierarchy.fcluster(Z, t=k, criterion='maxclust')` fails when the last merge heights are tied — may return fewer clusters than requested. Use `cut_tree(Z, n_clusters=k)` instead, which matches R's `cutree()` behavior.
- [R import_onehot format]: R's `import_onehot` produces one row per actor/group with W{w}_T{t} column naming (all windows concatenated). Python version produces one row per window with action_{i} columns. Different output shapes but both compatible with TNA analysis.
- [cluster_sequences R match]: Hamming distances, LCS distances, PAM clustering (assignments, silhouette, sizes), and hierarchical clustering (complete, average) all match R TNA exactly. Minor differences possible in hierarchical methods when merge distances are tied (tie-breaking differs between scipy and R hclust).
- [compare_sequences R match]: Frequencies (918 patterns) and proportions match R exactly to machine epsilon (~1e-16). R computes proportions per subsequence-length group BEFORE min_freq filtering (denominator includes all patterns, not just filtered ones). R runs permutation test on ALL patterns before filtering, so Bonferroni uses full pattern count per length. Output sorted by length then alphabetical (no test) or by p_value (with test).
- [compare_sequences permutation]: Pre-computing (row_index → pattern_indices) mapping speeds permutation loop ~3x: only need to re-accumulate counts by permuted group, not re-extract patterns each iteration.
- [compare_sequences p_adjust grouping]: R adjusts p-values separately per subsequence length group. E.g. 9 unigrams get Bonferroni factor 9, 78 bigrams get factor 78. Each raw p = 1/(iter+1) when all permuted stats < true stat.

### 2026-02-17
- [tnaj computeTransitions3D nCols bug]: `computeTransitions3D` uses `data[0].length` as the number of time steps for ALL sequences. With variable-length sequences (e.g. 2–26 in regulation data), only transitions up to the first sequence's length are counted — longer sequences are silently truncated. Fix: pad all sequences to max length with `null` before calling. The `null` values are caught by `isNA()` internally.
- [permutation test trueDiff mismatch]: Original permutation test computed true differences from `x.weights - y.weights` (original model weights), but permuted differences from `computeWeightsFrom3D(combinedTrans)`. Since each group model uses a different `nCols` (first sequence's length), the true and permuted weights were computed differently, making p-values systematically inflated (~0.9 for all edges). Fix: recompute true weights from the 3D transitions using the same pipeline as permutations.
- [multi-group grid layout]: For displaying all groups simultaneously, use CSS `grid-template-columns: repeat(auto-fit, minmax(500px, 1fr))` for responsive card layout. Scale network heights down in group mode: 450px for 2 groups, 380px for 3+. Use color-coded card headers with `nth-child` dot colors.
- [DOM ID collisions in multi-group]: When rendering the same tab type multiple times (once per group), all `getElementById` calls collide. Solution: add `idSuffix = ''` parameter to tab renderers, append `-g{index}` to every hardcoded ID. External renderers (bootstrap, betweenness, cliques, patterns, indices) get suffix as parameter; inline renderers (network, centralities, frequencies, sequences, communities) are duplicated as `*Multi` variants.
- [per-group caching]: Replace single `cachedModel`/`cachedCent` with `Map<string, TNA>` / `Map<string, CentralityResult>` for instant tab switching across groups. Populate all group caches upfront in `updateAll()`.
- [group-only tabs vs per-group tabs]: Tabs that compare across groups (permutation, compare-sequences, compare-networks) should NOT be multi-grouped — they already handle GroupTNA internally. Only per-group analysis tabs (network, centralities, bootstrap, etc.) get the multi-group grid treatment.

### 2026-02-18
- [R CTNA all-pairs]: R's co-occurrence counts ALL pairs `(i,j)` where `i < j` within each sequence, NOT just adjacent pairs. The 2D `_transitions_cooccurrence` in both Python and JS was wrong (adjacent only). The 3D `compute_transitions_3d`/`computeTransitions3D` was already correct. Fixed both 2D functions to match.
- [CTNA self-loop R behavior]: R's vectorized `trans[new_trans] <- trans[new_trans] + weight` with duplicate indices (self-loops where from==to) only applies the LAST assignment — effectively adding weight once, not twice. JS/Python `+= 1; += 1` accumulates twice. Fixed by guarding the symmetric write with `if (idx1 !== idx2)` in both 2D `transitionsCooccurrence` and 3D `computeTransitions3D` co-occurrence branches.
- [CTNA undirected rendering]: Co-occurrence matrices are symmetric. Network should render ONE undirected edge per pair (no arrowheads, straight lines), not two directed arrows. Self-loops also rendered without arrowheads.
- [rank scaling + symmetric matrix]: Rank scaling on a symmetric co-occurrence matrix produces `.50` values for ALL off-diagonal edges because every value `(i,j)` ties with its mirror `(j,i)`, giving average ranks ending in `.5`. This is expected behavior, not a bug.
- [model type change UX]: When user changes model type (TNA→CTNA etc.), reset scaling to "None" and threshold to 0 for a clean slate. Navigate to Network tab. Fully recalculate all models including group analysis.
- [chi-square mosaic]: State frequency × Cluster mosaic uses Pearson chi-square with adjusted standardized residuals. RdBu discrete color bins at ±2, ±4 thresholds. Dashed borders for negative residuals. P-value from regularized incomplete gamma function (Lanczos lgamma + series/continued-fraction gammaP).
- [difference network]: Compare Networks diff = modelA.weights - modelB.weights. Green (#28a745) for positive, red (#dc3545) for negative. Edge width ∝ |diff|.
- [tna-desktop three-mode nav]: Replaced flat 13-tab bar with two-level navigation: Mode bar (Single Network / Clustering / Group Analysis) + Subtab bar per mode. AppState uses `activeMode` + `activeSubTab` instead of `activeTab`. SETTINGS_VERSION bumped to 10. CSS uses `.mode-bar` (segmented control) + `.subtab-bar` (replaces `.tab-bar`). Group Analysis mode disabled when `!state.groupLabels`. Subtabs disabled until groups activated. clustering.ts exports `renderClusteringSetup`, `renderGroupSetup`, `renderGroupGrid`, `renderCombinedCanvas` for dashboard to compose.
- [bootstrap CI quantiles]: JS used `Math.floor` rank indexing for confidence intervals, which picks the nearest lower element. R's `stats::quantile` type 7 uses linear interpolation between adjacent order statistics: `idx = p * (n-1)`, then `sorted[floor(idx)] * (1-frac) + sorted[ceil(idx)] * frac`. tnaj's `arrayQuantile` already implements type 7 correctly.
- [permutation trueDiff source]: R computes `trueDiff = weights_x - weights_y` directly from model weights. JS was recomputing from padded/combined 3D transitions, which could differ from the original model weights due to the padding pipeline. Fixed to use model weights directly (permuted diffs still use the combined-transitions pipeline, matching R).
- [permutation paired option]: R supports `paired=TRUE` for equal-size groups: instead of full shuffle, randomly swap within each pair `(x_i, y_i)` with probability 0.5. Requires `nX === nY`.
- [stability NaN correlation]: Replacing `NaN` correlations with `0` inflates the proportion-above-threshold count (0 < threshold counts as "not above", but also inflates the denominator). Correct approach: filter NaN values before computing means and CS coefficients, matching R's `na.rm=TRUE` behavior.
- [stability spearman]: R supports `cor.method = "spearman"` for centrality stability. Spearman = Pearson on ranks. For tied values, use average ranks (mean of positions sharing the same value).
- [walktrap vs louvain]: Both tnaj and tna-desktop mapped walktrap to louvain. R's walktrap (Pons & Latapy 2005) is fundamentally different: computes P^t (t-step random walk distributions on the **directed** graph, default t=4), then Ward-style agglomerative clustering minimizing walk-distance, returning the partition at maximum modularity. All other community methods use symmetrized adjacency; walktrap is the only one that uses the directed graph.
- [pattern delimiter]: R TNA uses `->` as the n-gram pattern delimiter. JS was using ` → ` (Unicode arrow with spaces), causing pattern string mismatches when comparing outputs.
- [computeTransitions3D attention]: `computeTransitions3D` in tnaj had no attention branch — bootstrap/stability/permutation silently produced zero matrices for attention models. Added attention branch with `params?.beta` passthrough. Also added `params?: TransitionParams` to the TNA interface so `buildModel` preserves the beta value for downstream consumers.
- [R atna pipeline]: R's attention type uses `lambda` (default 1) with decay `exp(-abs(i-j)/lambda)`. JS uses `beta` (default 0.1) with `exp(-beta * distance)`. Equivalent when `beta = 1/lambda`. R's `compute_weights` just sums the 3D per-sequence arrays (`apply(transitions, c(2,3), sum)`) — no per-sequence normalization for attention. `scale_weights` only row-normalizes for `type == "relative"`.
- [louvain infinite loop]: tnaj's built-in louvain had `while (improved)` with no iteration limit — could hang indefinitely on certain graph topologies. Fixed with `maxIter = n * n`. tna-desktop's copy already had `MAX_PASSES = 50`.

### 2026-02-19
- [multi-group view toggles]: tna-desktop multi-group tabs now support nested toggles inside Figure view: Card/Bar/Line for frequencies/centralities, Cards/Combined for sequences/index, Stacked/Line for single-mode distribution. Pattern follows `createViewToggle` outer wrapper + inline `.toggle-btn` buttons.
- [combined sequence distribution]: Multi-group "Combined" view uses D3 stacked bar small multiples in 2-column grid with ONE shared legend below (not per-panel). Right margin reduced to 20px since legend is external.
- [combined sequence index]: Same small multiples pattern as distribution — 2-column grid of per-group sequence index plots with shared state legend below.
- [frequency line chart]: `renderFrequencyLines()` — one line per group, x=states (scaleBand), y=count. Same tooltip/legend pattern as `renderGroupedBars`.
- [distribution line chart]: `renderDistributionLines()` — one line per state, x=time step, y=proportion (0-1). Complements stacked bar `renderDistribution()`.
- [auto group activation]: When switching to Group Analysis or Group One-Hot mode, if `state.groupLabels` exists but groups aren't active, `buildColumnGroups()` runs automatically — no need for user to click "Run Group Analysis". Separated data-building (`buildColumnGroups`) from navigation (`activateColumnGroups`) to avoid double-rendering.
- [stability multi-group]: `renderCentStabilityViewMulti` dynamically creates per-group panels on Run click instead of pre-allocating empty placeholder panels. Uses `const idx = k` closure capture to avoid `requestAnimationFrame` bug where `k` increments before callback fires.
- [tnaj groupTna signature]: `groupTna(data: SequenceData, groups: string[])` takes flat sequence array + parallel group labels, NOT a Record<string, SequenceData>. Fixed in tnaj README (was documented incorrectly).
- [tnaj compareSequences signature]: `compareSequences(x: GroupTNA, options?)` takes GroupTNA, NOT `(data, groups, options?)`. Parameter is `sub` (not `lengths`) for subsequence lengths. Fixed in tnaj README.
- [plot_network pos parameter]: Added `pos: dict[str, tuple[float, float]] | None` to `plot_network()` and `plot_compare()`. When provided, layout algorithm is skipped entirely. Propagated through GroupTNA subplots.

### 2026-02-20
- [tnaj LCS fix]: tnaj `lcsDistance` used `Math.max(m, n) - lcsLength` (matching R TNA's formula), but R `stringdist` uses `m + n - 2 * lcsLength`. Fixed to match `stringdist` since clustering uses `stringdist` internally.
- [R stringdist jw p=0]: R's `stringdist(method="jw")` defaults to `p=0`, which is pure Jaro distance (NOT Jaro-Winkler). Jaro-Winkler requires explicit `p=0.1`. tnaj's `jaroWinklerDistance` defaults to `p=0` to match R.
- [R stringdist jaccard set-based]: R's jaccard distance on q-grams uses SET-based comparison (presence/absence of q-gram types), NOT frequency-weighted comparison. `1 - |intersection|/|union|` on the set of distinct q-gram types. Cosine uses frequency vectors.
- [PAM tie-breaking]: R's `cluster::pam` (C implementation) uses `>=` for BUILD phase gain comparison (last-wins when tied) and `<=` for first medoid selection (last-wins). JS implementation matched this but cluster label ordering still differs due to BUILD-order medoid listing vs sorted medoids.
- [canonical cluster labels]: PAM/hierarchical cluster assignments are equivalent up to label permutation. Use `canonicalize()` helper (first-seen cluster = 1, second = 2, etc.) to compare partitions across R and JS implementations. Silhouette scores are partition-invariant.
- [Lance-Williams hierarchical]: All 8 hierarchical methods (single, complete, average, mcquitty, median, centroid, ward.D, ward.D2) implemented via Lance-Williams recurrence formula with method-specific coefficients. Ward.D2 squares the distance matrix before clustering, then sqrt the merge heights. All match R `hclust` exactly on the test dataset.

### 2026-02-20
- [R onehot sliding window]: R's `import_onehot` sliding window uses iterative lag expansion, NOT traditional sliding windows. For each column: for w in 1..(ws-1), if current is active OR value w rows back (after previous iteration) is active → mark active. Then removes first row. Each remaining row is a "window". This causes forward propagation: effective lookback exceeds window_size. For ws=1, R's `seq(1, 0)` gives `c(1, 0)` — always applies lag(1), making ws=1 behave like ws=2.
- [R windowed co-occurrence algorithm]: R's `compute_transitions_windowed` for co-occurrence type iterates ALL (j,k) column pairs within each non-overlapping window (including j==k). Effective window = window_size * window_span. Windows computed as: `q = p %/% ew - (p %% ew == 0)`, `n_windows = q + 1`. Self-loops come naturally from j==k. Symmetry comes from iterating both (j,k) and (k,j).
- [R onehot window attrs]: `import_onehot` sets `window_size` attr = `window_size^(!aggregate)` (ws when not aggregate, 1 when aggregate) and `window_span` attr = `length(cols)`. These drive `compute_transitions_windowed`.
- [R inits for windowed CTNA]: Inits computed from first column of sequence matrix (`factor(x[, 1L], ...)`). When first column is all-NA (common in windowed data), R produces NaN (0/0). Python/JS must match this.
- [importOnehot return type change]: JS `importOnehot` now returns `OnehotSequenceData` with `{ sequences, windowSize, windowSpan }` instead of raw `SequenceData`. Callers that used the raw result need to use `.sequences` or pass the whole object to `ctna()`. Python attaches metadata via `DataFrame.attrs`.
